# ATRAP
ATRAP is an algorithm that builds a proof tree using several different proof
strategies. The goal is to make the algorithm powerful enough to find proof
trees that allow us to enumerate permutation classes avoiding few (1,2 or 3)
patterns of length four. In the beginning we will start with a relatively simple
algorithm that can handle bases with many length four patterns. As we consider
smaller bases we will start seeing the algorithm fail and will then add new
strategies to turn those failures into successes. We feel that it is natural to
start with a some known approach to connect with the current state of the
literature. Currently we want to take the regular insertion encoding as the
starting point. This is mainly because this is the only automatic method for
which you can know a priori whether or not it will succeed. This depends on
whether the basis of the permutation class intersects the permutation classes
Av(123, 3142, 3412) and Av(132, 312), as well as the reversals of these classes.
As the goal is to consider all bases of length four patterns, this condition
allows us discard a large number of bases and focus on more complicated ones.

Quick note on the current version: We have a version implementing strategies
that do not achieve mimicing regular insertion encoding. That version is hard
to add to so we are starting from scratch. The current version is however quite
powerful: It seems to be able to do all bases with at least one length three
and one length four pattern, as well as doing several interesting bases with
length four patterns.

## Roadmap

### Step 1: Mimic the regular insertion encoding
Recall how regular cell insertion finds the structure of the class Av(123, 132):

PICTURE1

The most basic implementation of ATRAP mimics the regular insertion encoding.
Notation: X is a permutation class, e is the empty permutation, X-e is a class
with the empty permutation removed, and o is the point. We start with X at the
root and use the following proof strategy to branch:

Cell specialization (cs): Given a cell marked with an X, create a left child
with X replaced by e, and a right child with X replaced by X-e.

PICTURE2

The left child is 'verified' meaning that it represents a subset of the class X.
To progress from the right child we need a new proof strategy:

Insert new maximum (nm): If there are no cells marked with 'X' in the top row of
the tiling then branch (into as many branches as there are X-e's) depending on
where the new maximum is. Note that illegal placements of the new maximum are
not drawn.

To mimic the loops in the automaton created by regular insertion encoding we
borrow reversibly-deletable points from enumeration schemes: A point o is
reversibly-deletable if there is an isomorphism between the subset of the class
X generated by a tiling T, and the subset of the class X generated by a tiling
T-o. We call this strategy recursion (r).

It should be easy to argue that this version of ATRAP is equivalent to regular
insertion encoding. The proof trees outputted by it should also be easily
turned into generating functions for the classes.

### Step 2: Generalizing (nm) and (r), adding (pp) and (rcs), and inferral
A natural generalization of (nm) is choosing a row or column and inserting a
new bottom-most or top-most point in the row; or a left-most or right-most point
in the column. We call this strategy row/column insertion (rci).

It is not settled what the first generalization of (r) will be, but probably
at least allowing reversibly-deletable cells (not just points). Also keep in
mind that non-ancestral recursions are easier to implement and understand.
Also note that recursions that stay with in a proof tree are easier to
understand.

Instead of having to consider entire rows or columns when inserting new points
we can take a cell marked with X-e and insert the top-most, bottom-most,
left-most, or right-most point into it. This is point-placement (pp).

PICTURE3

The proof strategy row-column separation (rcs) splits rows or columns depending
on whether crossing 12's or 21's are allowed. Think of the structure of
Av(231). Christian has generalized this to multiple cells in a row or a column.

PICTURE4

Finally, whenever we apply a proof strategy that adds a point or an X-e we
should infer what the rest of the cells need to avoid, instead of just marking
them with an X.

PICTURE5

With these proof strategies we should be able to find a proof tree for any
Av(B) such that B contains at least one length 3 pattern and one length 4
pattern.

At this stage I think a paper with the above results is in order.

Note that we can get a proof tree for Av(123) but it does not easily imply that
the class is counted by the Catalan numbers, see Step 3.

### Step 3: Generalizing (cs) and (r), adding fission/fusion (ff)
To be able to mimic Zeilberger's original enumeration schemes we need to have
fission and fusions of rows and columns.

PICTURE6
![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/pic6.jpg "Logo Title Text 1")

With these proof strategies we can find Zeilberger's original enumeration
schemes. In particular we will be able to find very similar trees for Av(123)
and Av(132). If we define isomorphisms of proof trees we can prove these are
Wilf-equivalent. From Step 2 we will have established that Av(132) is enumerated
by the Catalan numbers. This will finally give us a fully automatic
Wilf-classification of all subsets of S3.

The strategy (cs) creates two branches depending on whether a cell avoids the
pattern 1 (= is empty) or contains the pattern 1 (= is non-empty). This can be
generalized by replacing 1 with an arbitrary pattern p. Note that when we use
(pp) on a cell which we know contains a pattern p we need to use a binary mesh
pattern coincident with p. We call these strategies (csp) and (bmp). Note that
(csp) would imply we can do any Av(132, p) where p is any pattern (see paper by
Toufik and someone else).

At this stage we probably want to allow several recursions into the same tiling,
as well as recursions outside of the actual proof tree.

A natural follow-up being able to automatically Wilf-classify S3 is to try to do
as much as possible of S4. A nice goal would be at least all bases with four or
more patterns.

### Step 4, assuming there are still bases in S4 left: Gap matrices
Vatter defined gap vectors for his enumeration schemes. In some sense they are
tools for early termination of the nodes in the scheme. Our nodes are
two-dimensional so we can define (completely analogously) gap matrices

There is a slight generalization of (rcs) which might be useful at some point:
Branch into a left child where there is no crossing 12 between two cells, and
a right child where there is a crossing 12. This only works if the crossing 12
can be made unique some how (similar to a binary mesh pattern).
