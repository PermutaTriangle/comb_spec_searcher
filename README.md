# ATRAP

ATRAP is an algorithm that builds a proof tree using several different proof
strategies. The goal is to make the algorithm powerful enough to find proof
trees that allow us to enumerate permutation classes avoiding patterns of length
four. In the beginning we will start with a relatively simple algorithm that can
handle bases with many length four patterns. As we consider smaller bases we
will start seeing the algorithm fail and will then add new strategies to turn
those failures into successes. We feel that it is natural to start with a known
approach to connect with the current state of the literature. Currently we want
to take the regular insertion encoding as the starting point. This is mainly
because this is the only automatic method for which you can know a priori
whether or not it will succeed. This depends on whether the basis of the
permutation class intersects the permutation classes Av(123, 3142, 3412) and
Av(132, 312), as well as the reversals of these classes. As the goal is to
consider all bases of length four patterns, this condition allows us discard a
large number of bases and focus on more complicated ones.

Quick note on the current version: We have a version implementing strategies
that do not achieve mimicking regular insertion encoding. That version is hard
to add to so we are starting from scratch. The current version is however quite
powerful: It seems to be able to do all bases with at least one length three
and one length four pattern, as well as doing several interesting bases with
length four patterns.

## Roadmap

### Step 1: Mimick the regular insertion encoding
Recall how the regular insertion encoding finds the structure of the class
Av(123, 132):

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/rie_123_132.jpg "Regular insertion encoding of Av(123, 132)")

The most basic implementation of ATRAP mimicks the regular insertion encoding.
Notation for the next figure: X is a permutation class, epsilon (e here) is the
empty permutation, X with a dot in the middle (X-e here) is a class with the
empty permutation removed, and o is the point. We start with X at the root and
use the following proof strategy to branch:

_Cell specialization (cs)_: Given a cell marked with an X, create a left child
with X replaced by e, and a right child with X replaced by X-e.

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/basic_atrap_123_132.jpg "ATRAP mimicking regular insertion encoding")

The left child is 'verified' meaning that it represents a subset of the class X.
To progress from the right child we need a new proof strategy:

_Insert new maximum (nm)_: If there are no cells marked with 'X' in the top row of
the tiling then branch (into as many branches as there are X-e's) depending on
where the new maximum is. Note that illegal placements of the new maximum are
not drawn. (Also note that when this is applied with a single X-e then we don't
draw an edge pointing down, but rather an '=' since this is just another
viewpoint on the same subset of X.)

To mimick the loops in the automaton created by regular insertion encoding we
borrow reversibly-deletable points from enumeration schemes: A point o is
reversibly-deletable if there is an isomorphism between the subset of the class
X generated by a tiling T, and the subset of the class X generated by a tiling
T-o. We call this strategy _recursion (r)_. These are drawn with dashed arrows.

It should be easy to argue that this version of ATRAP is equivalent to regular
insertion encoding. The proof trees outputted by it should also be easily
turned into generating functions for the classes.

A final note on this version: Since we need to turn all X's in the top row into
X-e's before we can apply (nm) this implies that the algorithm explores exactly
one proof tree. This will change below when we have multiple choices for
proceeding from a tiling.

### Step 2: Generalizing (nm) and (r), adding (pp) and (rcs), and inferral of cells in a tiling
A natural generalization of (nm) is choosing a row or column and inserting a
new bottom-most or top-most point in the row; or a left-most or right-most point
in the column. We call this strategy row/column insertion (rci).

It is not settled what the first generalization of (r) will be, but probably
at least allowing reversibly-deletable cells (not just points). Also keep in
mind that non-ancestral recursions are easier to implement and understand.
Also note that recursions that stay within a proof tree are easier to
understand.

Instead of having to consider entire rows or columns when inserting new points
we can take a cell marked with X-e and insert the top-most, bottom-most,
left-most, or right-most point into it. This is _point-placement (pp)_.

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/pp.jpg "I like to think of these as different viewpoints on the same subset")

The proof strategy _row-column separation (rcs)_ splits rows or columns depending
on whether crossing 12's or 21's are allowed. Think of the structure of
Av(231). This can be generalized to multiple cells in a row or column.

For two cells ci and cj in the same row say ci < cj if i < j and placing a 21 is
not allowed or i > j and placing 12 is not allowed. If a row's cells forms a
partial order with this relation (it is possible for ci < cj and cj < ci) and
this forms a ranked poset (a poset that has the property that for every element
x, all maximal chains among those with x as greatest element have the same
finite length - this ensure minimal elements have the same rank) then the row
splits into multiple rows. The ith row has the cells of rank i.

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/rcs.jpg "If a crossing 21 is forbidden, split the row")

Finally, whenever we apply a proof strategy that adds a point or an X-e we
should _infer (i)_ what the rest of the cells need to avoid, instead of just marking
them with an X.

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/inf.jpg "The right-most cell must be decreasing")

With these proof strategies we should be able to find a proof tree for any
Av(B) such that B contains at least one length 3 pattern and one length 4
pattern.

At this stage I think a paper with the above results is in order.

Note that we can get a proof tree for Av(123) but it does not easily imply that
the class is counted by the Catalan numbers, see Step 3 below on isomorphic
proof trees.

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/current_atrap_123.png "Note that there is a decreasing cell that mixes into the recursed part")

### Step 3: Generalizing (cs) and (r), adding fission/fusion (ff)
To be able to mimick Zeilberger's original enumeration schemes we need to have
_fission and fusions (ff)_ of rows and columns.

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/ff.jpg "PSd = fission/fusion, PSe = row/column insertion")

Here is the enumeration scheme given by Zeilberger (he wrote it out in plain
English.)

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/es123.jpg "PSd = fission/fusion, PSe = row/column insertion")

With these proof strategies we can find Zeilberger's original enumeration
schemes. In particular we will be able to find a tree for Av(132)
which is almost the same as the one for Av(123):

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/es132.jpg "Sorry for the bad handwriting")

If we define isomorphisms of proof trees we can prove that Av(123) is
Wilf-equivalent to Av(132). From Step 2 we will have established that Av(132) is
enumerated by the Catalan numbers. This will finally give us a fully automatic
Wilf-classification of all subsets of S3.

The strategy (cs) creates two branches depending on whether a cell avoids the
pattern 1 (= is empty) or contains the pattern 1 (= is non-empty). This can be
generalized by replacing 1 with an arbitrary pattern p. On the right branch
where the pattern is contained (assuming this tiling is not verified) we can
use a binary mesh pattern coincident with p (we say two patterns are coincident
if Av(m) = Av(m'); a pattern is binary if it is contained in a permutation if
and only if it is contained exactly once in the permutation) to place the points
in the cell.

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/bmp.jpg "All the shadings are implied by the basis of X")

The 'binaryness' of the mesh pattern allows the placement of the points to be
unique, preserving enumeration. We call this generalization of (cs) _cell
specialization with a pattern (csp)_. Inserting a binary mesh pattern into the
cell we call _binary mesh pattern placement (bmpp)_. In the above figure the
basis of X implied all the shadings. In general we sometimes need to use a
result like the shading lemma og the shading algorithm to make the pattern
binary.

Having (csp) would imply we can do any Av(132, p) where p is any pattern (see
paper by Mansour and Vainshtein). We would want to prove a stronger result:
that we can do any subclass of Av(132).

At this stage we probably want to allow several recursions into the same tiling,
as well as recursions outside of the actual proof tree.

A natural follow-up being able to automatically Wilf-classify S3 is to try to do
as much as possible of S4. A nice goal would be at least all bases with four or
more patterns.

### Step 4, assuming there are still bases in S4 left :) : Gap matrices and more
Vatter defined gap vectors for his enumeration schemes. In some sense they are
tools for early termination of the nodes in the scheme. Our nodes are
two-dimensional so we can define (completely analogously) gap matrices

There is a slight generalization of (rcs) which might be useful at some point:
Branch into a left child where there is no crossing 12 between two cells, and
a right child where there is a crossing 12. This only works if the crossing 12
can be made unique some how (similar to a binary mesh pattern).

![alt text](https://github.com/PermutaTriangle/ATRAP/blob/master/figures_for_README/321_1342.png "A crossing inversion placed around the maximum")
